# Capsy v0.1 — 설계 및 구현 상세

> v0.1 정의: "루틴에 꽂히는 로컬 하네스"
> 설계 의도 / 구현 / 가드레일 / 배포 / 테스트가 한 세트로 닫힌 상태.

---

## Non-goals (v0.1에서 하지 않는 것)

- **LLM 연동 없음.** worklog를 쌓는 것이 목적. 요약·분석은 v0.2 예정.
- **자동 태스크 관리 없음.** `tasks.md`는 사용자가 직접 편집한다.
- **클라우드/동기화 없음.** 모든 데이터는 로컬 `.capsy/`에만 존재한다.
- **서버/데몬 없음.** 명령 하나가 실행되고 즉시 종료되는 단순 CLI다.

---

## 프로젝트 구조

```
capsy/
├── settings.gradle.kts              멀티모듈 선언
├── build.gradle.kts                 공통 설정 (Java 21, JUnit 플랫폼)
│
├── capsy-core/                      파일 시스템 로직 모듈
│   ├── build.gradle.kts             JUnit 5 의존성
│   └── src/
│       ├── main/java/io/capsy/core/
│       │   ├── CapsyInitializer.java    .capsy 폴더 초기화
│       │   └── WorklogWriter.java       worklog 파일 append
│       └── test/java/io/capsy/core/
│           ├── CapsyInitializerTest.java
│           └── WorklogWriterTest.java
│
└── capsy-cli/                       CLI 진입점 모듈
    ├── build.gradle.kts             application 플러그인, applicationName = "capsy"
    └── src/main/java/io/capsy/cli/
        └── CapsyApp.java            main(), 명령어 라우팅
```

---

## 모듈 분리 원칙

| 모듈 | 책임 | 하지 않는 것 |
|------|------|------------|
| `capsy-core` | 파일 시스템 조작 (생성, 읽기, append) | System.out 출력 없음 |
| `capsy-cli` | 입력 파싱, 출력, core 위임 | 파일 직접 조작 없음 |

`core`에 출력이 없는 이유: 나중에 CLI 외 다른 진입점(테스트, GUI, 다른 CLI)에서도 재사용할 수 있어야 하기 때문.

---

## Gradle 설정

### `settings.gradle.kts`

```kotlin
rootProject.name = "capsy"
include("capsy-core", "capsy-cli")
```

### `build.gradle.kts` (루트 — 공통)

```kotlin
subprojects {
    apply(plugin = "java")
    group = "io.capsy"
    version = "0.1.0-SNAPSHOT"
    repositories { mavenCentral() }

    extensions.configure<JavaPluginExtension> {
        toolchain.languageVersion.set(JavaLanguageVersion.of(21))
    }
    tasks.withType<Test> { useJUnitPlatform() }
}
```

`toolchain`을 명시하는 이유: 팀원마다 JDK 버전이 달라도 Java 21로 고정되어 빌드 재현성이 보장됨.

### `capsy-core/build.gradle.kts`

```kotlin
plugins { java }

dependencies {
    testImplementation("org.junit.jupiter:junit-jupiter:5.11.3")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}
```

`testImplementation`: 테스트 컴파일/실행에만 포함, 배포 jar에는 들어가지 않음.
`junit-platform-launcher`: 환경에 따라 없어도 동작하는 경우가 있지만, Gradle 9 + JUnit 5.11 조합에서 누락 시 테스트가 실행되지 않는 케이스가 확인되어 명시적으로 포함했다.

### `capsy-cli/build.gradle.kts`

```kotlin
plugins { java; application }

dependencies {
    implementation(project(":capsy-core"))
}

application {
    mainClass.set("io.capsy.cli.CapsyApp")
    applicationName = "capsy"   // installDist 결과물: bin/capsy
}

tasks.named<JavaExec>("run") {
    workingDir = rootProject.projectDir   // ./gradlew run 시 cwd를 레포 루트로 고정
}
```

`applicationName = "capsy"`: 이 설정 하나로 `installDist` 결과물이 `bin/capsy-cli` 대신 `bin/capsy`로 생성됨.
`workingDir` 고정: `Path.of("")`(cwd 기반)로 `.capsy`를 찾기 때문에, 개발 중 `./gradlew run` 실행 시에도 레포 루트가 기준이 됨.

---

## 핵심 클래스

### `CapsyInitializer` — `.capsy` 초기화

**idempotent 설계**: `init`을 여러 번 실행해도 기존 파일을 덮어쓰지 않음.

```
.capsy/
├── tasks.md                     Backlog / Next 섹션 템플릿
├── worklog/                     날짜별 worklog 파일 생성 위치
├── prompts/
│   ├── checkpoint.user.txt      {{WORKLOG_SNIPPET}} 플레이스홀더 포함
│   └── endday.user.txt          {{WORKLOG_SNIPPET}} 플레이스홀더 포함
├── schemas/                     v0.2 예정 — 빈 디렉토리만 생성
└── runs/                        v0.2 예정 — 빈 디렉토리만 생성
```

`{{WORKLOG_SNIPPET}}`은 v0.2에서 LLM에 worklog를 주입할 때 사용할 자리.
`schemas/`와 `runs/`는 v0.1에서 디렉토리만 예약 생성된다. 내용은 v0.2에서 채워진다.

핵심 메서드:
```java
private void createFileIfAbsent(Path path, String content) throws IOException {
    if (Files.notExists(path)) {
        Files.createDirectories(path.getParent());
        Files.writeString(path, content, StandardCharsets.UTF_8);
    }
}
```

---

### `WorklogWriter` — worklog append

오늘 날짜 `.md` 파일에 한 줄을 이어쓴다.

**출력 형식:**
```
# 2026-02-26

> Capsy worklog

- [14:30] CHECKPOINT: IntelliJ 멀티모듈 셋업 완료
- [18:00] ENDDAY: 오늘 init + 구조 + 푸시까지 완료
```

**설계 포인트:**

| 결정 | 이유 |
|------|------|
| `EntryType` enum | CHECKPOINT / ENDDAY 분기를 타입으로 표현, 문자열 실수 방지 |
| `appendEntry()` private template | 두 public 메서드의 공통 흐름을 한 곳에서 관리 |
| `StandardOpenOption.APPEND` | 파일을 덮어쓰지 않고 이어씀 |
| 줄바꿈 `"\n"` 고정 | `System.lineSeparator()` 사용 시 Windows에서 `\r\n` 섞임 → `.md` diff 오염 방지 |
| `Path.resolve()` 체이닝 | 문자열 슬래시(`"prompts/file"`) 대신 OS 무관한 Path API 사용 |

---

### `CapsyApp` — CLI 진입점

**책임:** 인자 파싱 + 출력 + core 위임. 파일 시스템을 직접 건드리지 않음.

**명령어 흐름:**

```
main(args)
  └── run(args)
        └── parse(args)  →  CommandRequest(command, message)
              └── switch
                    init  →  handleInit()         →  CapsyInitializer.init()
                    cp    →  handleCheckpoint()   →  requireInitialized() → WorklogWriter.appendCheckpoint()
                    day   →  handleEndday()       →  requireInitialized() → WorklogWriter.appendEndday()
                    help  →  printUsage()
```

**예외 계층:**

```java
catch (IllegalArgumentException e)  // 빈 메시지 등 입력 오류    → exit 1 + 사용법 출력
catch (IllegalStateException e)     // init 미실행 등 상태 오류  → exit 1
catch (IOException e)               // 파일 시스템 오류          → exit 2
catch (Exception e)                 // 예상 못한 오류            → exit 9
```

`IllegalArgumentException` vs `IllegalStateException`:
- `IllegalArgumentException`: 입력값 자체가 잘못됐을 때 (빈 메시지)
- `IllegalStateException`: 입력은 맞지만 실행 가능한 상태가 아닐 때 (init 미실행)

**guard 메서드:**

```java
private void requireInitialized(Path root) {
    if (!Files.isDirectory(root.resolve(".capsy"))) {
        throw new IllegalStateException(
                "Capsy가 초기화되지 않았습니다. 먼저 'capsy init'을 실행하세요.\n"
                + "   대상 경로: " + root
        );
    }
}
```

**`CommandRequest` 내부 DTO:**

`parse()` 결과를 `String[]` 그대로 넘기지 않고 구조체로 뽑아냄. 핸들러 시그니처가 깔끔해짐.

---

## 테스트

### 구성 원칙

- `capsy-core`만 테스트 (파일 시스템 로직이 핵심)
- CLI (`CapsyApp`)는 v0.1 범위에서는 테스트 생략
- `@TempDir`: JUnit 5가 임시 폴더 자동 생성/삭제 → 실제 `.capsy` 오염 없음

### `CapsyInitializerTest`

```java
@Test
void init_creates_tasks_and_prompts(@TempDir Path tempDir) throws IOException {
    new CapsyInitializer().init(tempDir);

    Path capsyDir = tempDir.resolve(".capsy");
    assertTrue(Files.exists(capsyDir.resolve("tasks.md")));
    assertTrue(Files.exists(capsyDir.resolve("prompts").resolve("checkpoint.user.txt")));
    assertTrue(Files.exists(capsyDir.resolve("prompts").resolve("endday.user.txt")));
}
```

검증: `init()` 실행 후 필수 파일 3개가 존재하는가.

### `WorklogWriterTest`

```java
@Test
void appendCheckpoint_writes_line_to_worklog(@TempDir Path tempDir) throws IOException {
    WorklogWriter writer = new WorklogWriter(tempDir);
    writer.appendCheckpoint("셋업 완료");

    String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
    Path worklogFile = tempDir.resolve(".capsy").resolve("worklog").resolve(today + ".md");

    assertTrue(Files.exists(worklogFile));
    String content = Files.readString(worklogFile);
    assertTrue(content.contains("CHECKPOINT"));
    assertTrue(content.contains("셋업 완료"));
}
```

검증: `appendCheckpoint()` 실행 후 오늘 날짜 `.md` 파일에 `CHECKPOINT` 라인이 포함되는가.

> **정책:** `cp`/`day`의 init 여부 검증은 CLI(`requireInitialized`)가 담당하고, `WorklogWriter`(core)는 append 자체만 책임진다.

---

## 배포

```bash
# 빌드
./gradlew :capsy-cli:installDist

# 결과물 위치
capsy-cli/build/install/capsy/
├── bin/
│   ├── capsy        Unix 실행 스크립트
│   └── capsy.bat    Windows 실행 스크립트
└── lib/
    ├── capsy-cli-0.1.0-SNAPSHOT.jar
    └── capsy-core-0.1.0-SNAPSHOT.jar

# PATH 등록 (레포 루트에서)
export PATH="$PATH:$(pwd)/capsy-cli/build/install/capsy/bin"
```

shadowJar(단일 fat jar)는 v0.2 예정. v0.1에서는 `installDist`로 충분히 "명령어처럼" 사용 가능.

---

## v0.1 완료 체크리스트

| 항목 | 상태 |
|------|------|
| Gradle 멀티모듈 구조 (core / cli 분리) | ✅ |
| `.capsy` 초기화 (`init`, idempotent) | ✅ |
| `cp` / `day` worklog append | ✅ |
| `init` 미실행 방어 (guard) | ✅ |
| `installDist` 배포 (`capsy` 명령어) | ✅ |
| 테스트 2개 (JUnit 5, `@TempDir`) | ✅ |
| `.gitignore` 정리 | ✅ |

---

## v0.2 예정

1주 실사용 후 자연스럽게 나오는 요구사항만 반영 예정.

예상 후보:
- `tasks.md` 자동 갱신 (`next` 명령)
- LLM 연동 (worklog → 요약)
- shadowJar (단일 실행 파일)
